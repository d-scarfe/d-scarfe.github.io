[{"categories":["java"],"content":"In this article, we’re going to build a reactive REST API in Java using Spring’s WebFlux and annotation processing. We’ll demonstrate how to make use of Flux and Mono publishers to serve JSON content to the client. This tutorial shall provide the basis from which we can build a reactive, scalable web backend in Java. ","date":"2022-05-30","objectID":"/java/spring-webflux/:0:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Introducing Spring WebFlux ","date":"2022-05-30","objectID":"/java/spring-webflux/:1:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Why choose WebFlux? WebFlux is Spring’s answer to the need for a non-blocking web stack that handles concurrency with fewer threads, and scales with less reliance upon physical hardware. WebFlux builds upon Project Reactor, a well-loved enterprise framework that provides non-blocking message parsing with a focus on low memory usage \u0026 a high throughput. Let us first recap how Spring MVC functions, which many of us are familiar with. In this implementation, a single thread is created to service each request. Whilst this approach is easy to debug \u0026 understand, each thread typically utilises 1MB of heap to fulfil the request. When faced with many concurrent users, this approach can present a number of scaling issues. In contrast, WebFlux’s reactive model keeps the thread pool small. The non-blocking approach brings about a significant leap in performance, whilst the annotation-based processing feels familiar \u0026 comfortable for those who have worked with Spring before. if you are looking to produce a reactive Java backend, in an environment where efficiency and/or resource utilisation are of utmost importance, WebFlux is the perfect tool. But allow me to be clear, whilst reactive frameworks are powerful \u0026 scale well, they can be more difficult to implement \u0026 debug. If you have a Spring MVC application that is sufficient for your needs, there is no need to convert it to WebFlux. The old mantra of “if it ain’t broke, don’t fix it” applies! ","date":"2022-05-30","objectID":"/java/spring-webflux/:1:1","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Who is using WebFlux? WebFlux facilitates the backend for a number of large organisations working in Java. One notable example includes JP Morgan, whose financial platform is used by hundreds of thousands of clients around the world. Their application therefore needs to service a large number of concurrent requests in a trading environment where high throughput is vital. The reactive model is cornerstone to this solution. ","date":"2022-05-30","objectID":"/java/spring-webflux/:1:2","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Our Mission ","date":"2022-05-30","objectID":"/java/spring-webflux/:2:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"What are we making? In the following example, we’ll build a reactive REST API which provides a number of endpoints capable of responding to HTTP requests. We will start by implementing some simple GET endpoints, and then we will add support for POST requests. We shall test the API by performing some basic CRUD operations to manipulate an example in-memory dataset. ","date":"2022-05-30","objectID":"/java/spring-webflux/:2:1","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"What do I need? This article assumes that the reader has already installed JDK 8 onwards, alongside a recent version of Apache Maven. There are no other requirements for this project. All testing will be done within Java. ","date":"2022-05-30","objectID":"/java/spring-webflux/:2:2","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Getting Started ","date":"2022-05-30","objectID":"/java/spring-webflux/:3:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Initial setup Let’s create a new Maven project, and add the following WebFlux dependency: \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-webflux\u003c/artifactId\u003e \u003cversion\u003e2.7.0\u003c/version\u003e \u003c/dependency\u003e This will pull in a number of required dependencies, including: spring-boot-starter to provide us with a Spring Boot base. spring-webflux to provide us with our WebFlux framework. reactor-core to provide us with the reactive streams API. reactor-netty to provide us with an embedded web server. The version 2.7.0 was correct at the time of writing, but it is always worth validating against Maven Central. ","date":"2022-05-30","objectID":"/java/spring-webflux/:3:1","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Project structure Since we have a blank project, let’s go ahead and create the following directories: src/main/java/uk/scarfe/webflux/ which will be our base package for the project. .../webflux/model which shall contain our example data model. .../webflux/annotation which will demonstrate annotation-based WebFlux deployment. .../webflux/functional which will demonstrate functional style WebFlux deployment. Later we will add some automated tests, but we needn’t worry about those for now. ","date":"2022-05-30","objectID":"/java/spring-webflux/:3:2","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Introducing Flux \u0026 Mono Before we get started with our Webflux application, we must familiarise ourselves with its two publisher implementations, Flux and Mono. Mono is a Publisher that emits at most 1 element: Mono\u003cString\u003e mono = Mono.just(\"Daniel\"); Mono\u003cObject\u003e monoEmpty = Mono.empty(); Mono\u003cObject\u003e monoError = Mono.error(new RuntimeException()); In contrast, Flux is a publisher that emits 0 to n number of elements: Flux\u003cInteger\u003e flux = Flux.just(1, 2, 3, 4, 5); Flux\u003cString\u003e fluxString = Flux.fromArray(new String[]{\"A\", \"B\", \"C\"}); Flux\u003cString\u003e fluxIterable = Flux.fromIterable(Arrays.asList(\"A\", \"B\", \"C\")); Flux\u003cInteger\u003e fluxRange = Flux.range(0, 10); Flux\u003cLong\u003e fluxLong = Flux.interval(Duration.ofSeconds(60)); The Flux instance returns a sequence of elements and notifies upon completion. Note that despite creating the Flux instance, the data will not flow until .subscribe() is called: List\u003cString\u003e dataStream = new ArrayList\u003c\u003e(); Flux.just(\"Daniel\", \"David\", \"Dory\", \"Diana\") .log() .subscribe(dataStream::add); Project Reactor also provides us with a number of stream-based operators, including .map()/.flatMap()/.merge()/.concat() and more. Readers should take a moment to familiarise themselves with the API, as it is an incredibly powerful toolset when mastered. ","date":"2022-05-30","objectID":"/java/spring-webflux/:4:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Annotation Approach ","date":"2022-05-30","objectID":"/java/spring-webflux/:5:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Defining the data model Let’s go ahead and create our application. We start by creating a POJO that will store some example data. In this instance, we’re going to create an Employee class under the model namespace: package uk.scarfe.webflux.model; import java.util.Objects; public class Employee { private final long id; private final String name; public Employee() { this.id = -1; this.name = \"\"; } public Employee(long id, String name) { this.id = id; this.name = name; } public long getId() { return id; } public String getName() { return name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return id == employee.id \u0026\u0026 Objects.equals(name, employee.name); } @Override public int hashCode() { return Objects.hash(id, name); } } In the above example, we have created a basic immutable class that stores an employee ID and a name. It should be noted that we need the default no-args constructor to faciliate serialisation of the data. We’ve implemented an .equals() and .hashCode() so we can identify two equal Employee instances. ","date":"2022-05-30","objectID":"/java/spring-webflux/:5:1","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Creating a controller Now we need to create a controller who is responsible for handling our request and creating the response. Let’s add an EmployeeController class under the controllers package: package uk.scarfe.webflux.annotation; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Flux; import uk.scarfe.webflux.model.Employee; import java.util.Arrays; import java.util.List; @RestController @RequestMapping(\"/employees\") public class EmployeeController { public static final List\u003cEmployee\u003e EMPLOYEES = Arrays.asList(new Employee(1, \"Daniel Scarfe\"), new Employee(2, \"Joe Bloggs\")); @GetMapping public Flux\u003cEmployee\u003e getAll() { return Flux.fromIterable(EMPLOYEES); } } This simple reactive class provides a GET mapping for /employees that will return a Flux object containing two hard-coded Employee instances. In practice, you would likely retrieve your content from a data store, but we are merely demonstrating the reactive layer here. ","date":"2022-05-30","objectID":"/java/spring-webflux/:5:2","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Creating a client Now we have our server-side implementation, we can make use of a Spring’s WebClient to provide client-side access. The WebClient is Spring’s non-blocking approach to performing HTTP requests. Let’s implement an EmployeeClient class which connects to the default port of 8080: package uk.scarfe.webflux.annotation; import org.springframework.stereotype.Component; import reactor.core.publisher.Flux; import org.springframework.http.MediaType; import org.springframework.web.reactive.function.client.WebClient; import uk.scarfe.webflux.model.Employee; @Component public class EmployeeClient { private static final String BASE_URL = \"http://localhost:8080\"; private final WebClient client; public EmployeeClient(WebClient.Builder builder) { this.client = builder.baseUrl(BASE_URL).build(); } public Flux\u003cString\u003e getEmployeeNames() { return this.client.get().uri(\"/employees\").accept(MediaType.APPLICATION_JSON) .retrieve() .bodyToFlux(Employee.class) .map(Employee::getName); } } In the above code, we’ve implented some basic logic to get all employee names as a Flux\u003cString\u003e. Any caller subscribing to this flux will receive the full list of names upon completion. ","date":"2022-05-30","objectID":"/java/spring-webflux/:5:3","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Running the application Let’s make our application executable, by creating an Application class that utilises @SpringBootApplication annotation: package uk.scarfe; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; import uk.scarfe.webflux.annotation.EmployeeClient; @SpringBootApplication public class Application { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(Application.class, args); EmployeeClient client = context.getBean(EmployeeClient.class); client.getEmployeeNames().subscribe(System.out::println); } } Thanks to Spring Boot’s auto-configuration, this is all we need to do. Spring Boot will automatically start our Netty server on port 8080 and perform injection of the relevant dependencies. By retrieving the EmployeeClient from the application context and subscribing to the publisher instance, we can retrieve the employee data in a non-blocking manner. If you go ahead and run the application you will see our two employee names printed to the console: uk.scarfe.Application : Started Application in 1.978 seconds (JVM running for 2.435) Daniel Scarfe Joe Bloggs There you have it. We have successfully demonstrated how to utilise Spring’s annotation-based processing (similar to that of Spring MVC) to produce a reactive web backend in Java. Implementing additional PUT / POST / DELETE functionality is as simple as using the corresponding annotations: @PostMapping @ResponseStatus(HttpStatus.CREATED) public Mono\u003cEmployee\u003e create(@RequestBody Employee employee){ // As we have not created an 'employeeService' yet, this is merely an example. return employeeService.createEmployee(employee); } Annotation-based processing isn’t for everybody. In the next section, we will evaluate the functional approach also supported by WebFlux. ","date":"2022-05-30","objectID":"/java/spring-webflux/:5:4","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Functional Approach The “Spring Functional Web Framework” was designed for Spring WebFlux, but has now also been introduced to Spring MVC. Instead of using the annotation-based approach, we can utilise functions for routing \u0026 handling our HTTP requests. ","date":"2022-05-30","objectID":"/java/spring-webflux/:6:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Implementing a service To avoid mixing the two approaches, we’re going to create a very basic EmployeeService like so: package uk.scarfe.webflux.functional; import org.springframework.stereotype.Component; import reactor.core.publisher.Mono; import uk.scarfe.webflux.model.Employee; import java.util.Optional; import static uk.scarfe.webflux.annotation.EmployeeController.EMPLOYEES; @Component public class EmployeeService { public Mono\u003cEmployee\u003e getById(long id) { final Optional\u003cEmployee\u003e foundEmployee = EMPLOYEES.stream().filter(e -\u003e e.getId() == id).findAny(); return foundEmployee.map(Mono::just).orElseGet(Mono::empty); } } The only public facing method, getById() shall return a Mono instance containing an employee corresponding to the given ID value, or Mono.empty() if one is not present. ","date":"2022-05-30","objectID":"/java/spring-webflux/:6:1","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Creating the handler Nowe we create an EmployeeHandler that can accept a ServerRequest and returns a response containing our employee object: package uk.scarfe.webflux.functional; import org.springframework.http.MediaType; import org.springframework.stereotype.Component; import org.springframework.web.reactive.function.server.ServerRequest; import org.springframework.web.reactive.function.server.ServerResponse; import reactor.core.publisher.Mono; import uk.scarfe.webflux.model.Employee; @Component public class EmployeeHandler { private final EmployeeService employeeService; public EmployeeHandler(EmployeeService employeeService) { this.employeeService = employeeService; } public Mono\u003cServerResponse\u003e getById(ServerRequest request) { final long id = Long.parseLong(request.pathVariable(\"id\")); return employeeService .getById(id) .flatMap(e -\u003e ServerResponse.ok() .contentType(MediaType.APPLICATION_JSON) .body(Mono.just(e), Employee.class) ) .switchIfEmpty(ServerResponse.notFound().build()); } } Note the functional style. The “id” path variable is passed into the .getById() call, and the result is flat-mapped into a ServerResponse. The Employee instance that matches our ID value is stored in the body of the response, and a HTTP 200 OK is sent. In the event an employee instance corresponding to our ID cannot be verified, the .switchIfEmpty() statement ensures that a HTTP 404 Not Found response is sent instead. ","date":"2022-05-30","objectID":"/java/spring-webflux/:6:2","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Defining our routes Finally, we create an EmployeeRouter which provides the route configuration for our endpoint mapping: package uk.scarfe.webflux.functional; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.server.RouterFunction; import org.springframework.web.reactive.function.server.ServerResponse; import static org.springframework.web.reactive.function.server.RequestPredicates.GET; import static org.springframework.web.reactive.function.server.RouterFunctions.route; @Configuration public class EmployeeRouter { @Bean public RouterFunction\u003cServerResponse\u003e employees(EmployeeHandler employeeHandler) { return route(GET(\"/employees/{id}\"), employeeHandler::getById); } } Here we can see that we have mapped a GET endpoint at \"/employees/{id}\" and delegated to the .getById() function in EmployeeHandler. The class is annotated with @Configuration so Spring will construct our RouterFunction bean \u0026 automatically configure our Netty server accordingly. ","date":"2022-05-30","objectID":"/java/spring-webflux/:6:3","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Automated Testing Whilst manual testing has it’s place in software development, all good projects will have proper automated testing, and this is no exception. Fortunately, Spring makes the testing of REST APIs very easy. Let’s go ahead and add the following dependencies to our pom.xml: \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003eRELEASE\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cversion\u003e2.7.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e ","date":"2022-05-30","objectID":"/java/spring-webflux/:7:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Validating a Flux response Now we can test our endpoints by creating an EmployeeHandlerTest with JUnit 5. Let’s start by testing the .getAll() method: package uk.scarfe.webflux; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.context.junit.jupiter.SpringExtension; import org.springframework.test.web.reactive.server.WebTestClient; import uk.scarfe.webflux.model.Employee; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static uk.scarfe.webflux.annotation.EmployeeController.EMPLOYEES; @ExtendWith(SpringExtension.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class EmployeeHandlerTest { // Spring Boot will create a pre-configured `WebTestClient` for you. @Autowired private WebTestClient webTestClient; @Test public void testGetAll() { webTestClient.get().uri(\"/employees\") .accept(MediaType.APPLICATION_JSON) .exchange() .expectStatus().isOk() .expectBodyList(Employee.class) .isEqualTo(EMPLOYEES); } } Thanks to Spring Boot, the web environment is started on a random available port, and the WebTestClient is automatically configured to test against it. We simply inject this into our test suite and then use the functional API to assert that our responses match our desired behaviour. ","date":"2022-05-30","objectID":"/java/spring-webflux/:7:1","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Validating a Mono response We can extend our test suite further, by validating calls to .getById() like so: @Test public void testGetById() { webTestClient.get().uri(\"/employees/1\") .accept(MediaType.APPLICATION_JSON) .exchange() .expectStatus().isOk() .expectBody(Employee.class).value(employee -\u003e { assertEquals(\"Daniel Scarfe\", employee.getName()); }); } Here we make use of .expectBody(...) to validate that the body of the JSON response contains our desired Employee instance. ","date":"2022-05-30","objectID":"/java/spring-webflux/:7:2","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Validating error scenarios Finally, it’s always worth testing the various error scenarios, such as when an item cannot be found: @Test public void testNotFound() { webTestClient.get().uri(\"/employees/123\") .accept(MediaType.APPLICATION_JSON) .exchange() .expectStatus().isNotFound(); } In this example, we tell the test client to expect a “Not Found” response because no employee exists with ID #123. Of course, the implementation has both functional \u0026 annotation styles, but the testing methodology remains the same. This represents a very powerful way of testing APIs; the overall suite takes milliseconds to run, yet can provide complete coverage with minimal effort. ","date":"2022-05-30","objectID":"/java/spring-webflux/:7:3","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["java"],"content":"Conclusion In this article, we explored how to create \u0026 work with the reactive web components supplied by the Spring WebFlux framework. As an example, we built a small reactive REST API for retrieving employee data in a non-blocking manner. We introduced both the Flux and Mono publisher implementations, available through Project Reactor / JDK 9 onwards. Then we learned how to use RestController and WebClient to publish \u0026 consume our reactive streams in the JVM. We also reviewed the functional approach to creating WebFlux applications, and demonstrated how to test the application in JUnit 5. ","date":"2022-05-30","objectID":"/java/spring-webflux/:8:0","tags":["rest","java","spring","reactive","web"],"title":"Building a REST API with Spring WebFlux","uri":"/java/spring-webflux/"},{"categories":["scala"],"content":"In this article, we’re going to build a simple REST API in Scala using the Play Framework. We shall utilise HTTP requests to perform basic CRUD operations on an example dataset. We’ll demonstrate (in Scala) how we can serve our content back to the user in the JSON format. This tutorial shall provide the basis from which we can build efficient, scalable backend systems. ","date":"2022-05-29","objectID":"/scala/play-framework/:0:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Introducing the Play Framework ","date":"2022-05-29","objectID":"/scala/play-framework/:1:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Why choose Play? The Play Framework encourages scalability whilst managing to remain simple to use. It remains true to the MVC paradigm, but builds upon reactive principles, meaning that the concept feels familiar but the resulting product is highly performant. For me personally, the biggest advantage of the Play Framework is performance. Play’s threading model means that it is both fast \u0026 resource efficient. This is in contrast to the more traditional approach to MVC, such as Spring’s implementation in Java, whereby a single thread is created for each request. Whilst this approach is easy to debug \u0026 understand, each thread typically utilises 1MB of heap to service the request. When faced with many concurrent users, this approach can present a number of scaling issues. ","date":"2022-05-29","objectID":"/scala/play-framework/:1:1","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Who is using Play? Some key players using the Play Framework in industry include LinkedIn and Walmart. Both of these large organisations handle millions of requests daily, which demonstrates the power \u0026 scalability of the framework. Since its initial release in 2007, Play has become a much loved web framework for the Java \u0026 Scala community. ","date":"2022-05-29","objectID":"/scala/play-framework/:1:2","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Our Mission ","date":"2022-05-29","objectID":"/scala/play-framework/:2:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"What are we making? In the following example, we’ll build a very simple REST API which provides a number of endpoints capable of responding to HTTP requests. We will start by implementing a simple GET endpoint, and then we will add support for POST \u0026 DELETE requests. We shall test the API by performing some basic CRUD operations to manipulate an example in-memory dataset. ","date":"2022-05-29","objectID":"/scala/play-framework/:2:1","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"What do I need? This article assumes that the reader has already installed a recent version of sbt. We will peform basic API testing using curl on the command line. Some readers may prefer to use a graphical testing tool, such as Postman. ","date":"2022-05-29","objectID":"/scala/play-framework/:2:2","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Getting Started ","date":"2022-05-29","objectID":"/scala/play-framework/:3:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Initial setup For convenience, we can start our new Play Framework project using an sbt template: $ sbt new playframework/play-scala-seed.g8 This creates a new Scala project with an example controller, two HTML files and basic configuration. Let’s go ahead and delete some of these components so that we have a “clean slate” to work from: $ rm -rf app/controllers/HomeController.scala $ rm -rf app/views/index.scala.html app/views/main.scala.html $ truncate -s 0 conf/routes ","date":"2022-05-29","objectID":"/scala/play-framework/:3:1","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Project structure Now we can take a look at the various directories in a little more detail: app/controllers/ shall contain our Scala classes used to handle the HTTP events. app/models/ shall contain our data objects, in the form of Scala classes. app/views/ shall contain any HTML template files (not used in this tutorial). conf/ shall contain the configuration used to wire everything together. Note the familiarity of the package names above; Model, View, Controller (MVC). ","date":"2022-05-29","objectID":"/scala/play-framework/:3:2","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Our First GET Endpoint We begin by creating a simple REST endpoint that responds to HTTP GET requests and provides a NoContent response. This is arguably the most simple endpoint we can make, but it is useful in helping to demonstrate the classes involved. ","date":"2022-05-29","objectID":"/scala/play-framework/:4:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Creating a controller First, we create an EmployeeController class in the app/controllers directory: package controllers import javax.inject.Singleton import com.google.inject.Inject import play.api.mvc.{Action, AnyContent, BaseController, ControllerComponents} @Singleton class EmployeeController @Inject()(val controllerComponents: ControllerComponents) extends BaseController { // Business logic goes here! } Our new class must extend the BaseController trait, which gives us access to Action and Results functionality. We’ve used the @Inject annotation to instruct the Play Framework to pass the required dependencies automatically via constructor injection. Also, we marked the class as a @Singleton so that the framework will create only one instance, reusing it for every request. ","date":"2022-05-29","objectID":"/scala/play-framework/:4:1","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Our response function Now we have a EmployeeController, let’s create the method within that will be called when our server receives a REST request. First, we define a getAll function that returns an aforementioned Action: def getAll(): Action[AnyContent] = Action { NoContent } The Action class gives us access to request parameters and allows us to return a HTTP response. For now, we simply return a NoContent status, because we have no content to return. ","date":"2022-05-29","objectID":"/scala/play-framework/:4:2","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Enabling the endpoint Before we create our content, let’s add the controller to the routes file: GET /employees controllers.EmployeeController.getAll() We must specify the HTTP method, the path, and the name of the Scala function that handles the request. The only separater here is whitespace, but we format it into columns for readability. ","date":"2022-05-29","objectID":"/scala/play-framework/:4:3","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Running the application Now we have enabled our endpoint, we can go ahead and start the application: $ sbt run 9000 After a short while, we’ll see the following message: [info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:9000 This indicates that the application has started \u0026 is ready to handle requests. Let’s make our first HTTP GET call using curl like so: $ curl -v localhost:9000/employees You will be greeted with a HTTP/1.1 204 No Content response. Et voilà! We now have a working RESTful API using Scala \u0026 the Play Framework. Granted, it is a little basic, so let’s continue to add some more functionality. ","date":"2022-05-29","objectID":"/scala/play-framework/:4:4","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Returning JSON Content So far we have returned only a NoContent response. That suffices for proving we can build a running Play application, but you aren’t going to build an enterpise backend on that. At the very least, we need to be able to return some meaningful content. Let’s produce some. Now, we are going to look at returning an Employee list. Let’s define the data model, create an in-memory collection of employees, and modify the EmployeeController to return JSON objects. ","date":"2022-05-29","objectID":"/scala/play-framework/:5:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Defining the data model First, we create a new case class in the app/models directory: package model case class Employee(id: Long, name: String) Now, we define the list of tasks in the EmployeeController class. As this list will be modified, we need Scala’s mutable collections package: ... import model.Employee import scala.collection.mutable class EmployeeController @Inject()(val controllerComponents: ControllerComponents) extends BaseController { private val employeeList = new mutable.ListBuffer[Employee]() employeeList += Employee(1, \"Daniel Scarfe\") employeeList += Employee(2, \"Joe Bloggs\") ... To make testing our application easier, we’ve hardcoded a number of values here, but in practice you would likely retrieve this information from a data store. ","date":"2022-05-29","objectID":"/scala/play-framework/:5:1","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Formatting into JSON Next, let’s create the JSON formatter that converts the Employee object into JSON. We add our required imports, then create the JSON formatter inside the EmployeeController class: ... import play.api.libs.json.{Json, OFormat} @Singleton class EmployeeController @Inject()(val controllerComponents: ControllerComponents) extends BaseController { implicit val formatter: OFormat[Employee] = Json.format[Employee] ... We make it an implicit field to avoid having to pass it to the Json.toJson function on each usage. ","date":"2022-05-29","objectID":"/scala/play-framework/:5:2","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Implementing our response Now we have some data to return, let’s change our getAll function to return the NoContent status code only when the list is empty. Otherwise, it shall return the complete employee list, converted to JSON by the formatter: def getAll(): Action[AnyContent] = Action { if (employeeList.isEmpty) { NoContent } else { Ok(Json.toJson(employeeList)) } } Let’s re-test the endpoint using the same statement as before: $ curl localhost:9000/employees [{\"id\": 1, \"name\": \"Daniel Scarfe\"},{\"id\": 2, \"name\": \"Joe Bloggs\"}] We have successfully returned a list of employees in JSON format. ","date":"2022-05-29","objectID":"/scala/play-framework/:5:3","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Handling parameterised calls A good REST API shall also allow you to retrieve individual items via a path parameter like so: $ curl localhost:9000/employees/1 This shall return the item, or NotFound if the employee ID is not recognised. Let’s implement that. First, we define a new endpoint in the routes file: GET /employees/:id controllers.EmployeeController.getById(id: Long) The notation /employees/:id means that the Play Framework shall capture everything after the /employee/ prefix and assign it to the id variable. This value is then passed into the getById function, which we haven’t written yet. Note that we have specified a type for the parameter (Long). The Play Framework will automatically convert text to a number, and return a BadRequest response if the provided value is not a number. We can now add the getById method in the EmployeeController class: def getById(id: Long): Action[AnyContent] = Action { val foundEmployee = employeeList.find(_.id == id) foundEmployee match { case Some(employee) =\u003e Ok(Json.toJson(employee)) case None =\u003e NotFound } } Our method retrieves the id parameter and tries to find the employee list item associated with it. We’re using the find function, which returns an instance of the Option class. As such, we can make use of pattern matching to distinguish between an empty Option and an Option with a value, as seen above. When the employee is present in the employee list, it’s converted into JSON returned in an OK response. Otherwise, NotFound is returned, resulting in HTTP 404. Now, we can try to get an employee that is in our list: $ curl localhost:9000/employees/1 {\"id\":1,\"name\":\"Daniel Scarfe\"} Or perhaps try an employee that isn’t: $ curl -v localhost:9000/employees/3 HTTP/1.1 404 Not Found ","date":"2022-05-29","objectID":"/scala/play-framework/:5:4","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Implementing POST The Play Framework handles all HTTP methods, so when we want to use PUT / POST / DELETE, we simply configure it in the routes file. As an example, let’s implement an POST endpoint that allows us to create a new employee. We shall start by adding another entry in our routes file: POST /employees controllers.EmployeeController.addNewEmployee() Then, as before, we simply add the business logic into the EmployeeController class: def addNewEmployee(): Action[AnyContent] = Action { implicit request =\u003e // Extract the JSON object from the request body. val body: AnyContent = request.body val jsonBody: Option[JsValue] = body.asJson val newEmployee: Option[Employee] = jsonBody.flatMap(js =\u003e Json.fromJson[Employee](js).asOpt) // If present \u0026 valid, add to list and return a Created response. newEmployee match { case Some(employee) =\u003e employeeList.addOne(employee) Created(Json.toJson(employee)) case None =\u003e BadRequest } } In our method, body.asJson parses the given JSON object and returns an Option. We would get a valid object only if the deserialisation were successful. If the caller has sent us content that cannot be deserialised as an Employee, or if the Content-Type is not application/json, we end up with a None type and a BadRequest response is sent. Otherwise, our new Employee instance is added to our employeeList, and a HTTP 201 Created response is returned to the client. We can now try to add a new employee using the API like so: $ curl -d '{\"id\":3,\"name\":\"James Blunt\"}' -H 'Content-Type: application/json' localhost:9000/employees HTTP/1.1 201 Created. {\"id\": 3,\"name\": \"James Blunt\"} As we can see from our 201 Created response, the new item has been added and subsequently returned in the response body. To verify that the item was added to our in-memory data store, we can retrieve all items again: $ curl localhost:9000/employees [ {\"id\": 1, \"name\": \"Daniel Scarfe\"}, {\"id\": 2, \"name\": \"Joe Bloggs\"}, {\"id\": 3, \"name\": \"James Blunt\"} ] This time, the JSON array shall contain three objects, including our new employee instance. ","date":"2022-05-29","objectID":"/scala/play-framework/:6:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Implementing DELETE Finally, let’s add support for deleting items from the list using a HTTP DELETE request. As before, we add our business logic to the EmployeeController class: def deleteById(id: Long): Action[AnyContent] = Action { val foundEmployee = employeeList.find(_.id == id) foundEmployee match { case Some(employee) =\u003e employeeList -= employee Ok case None =\u003e NotFound } } Then we configure the route: DELETE /employees/:id controllers.EmployeeController.deleteById(id: Long) And we test our endpoint using curl like so: $ curl -v -X DELETE localhost:9000/employees/3 HTTP/1.1 200 OK. Note here that we have chosen to simply return an OK response with no body, for simplicity. We perform one final validation to make sure that the item has been removed from the list: $ curl localhost:9000/employees [{\"id\": 1, \"name\": \"Daniel Scarfe\"},{\"id\": 2, \"name\": \"Joe Bloggs\"}] A second attempt will result in a “HTTP 404 Not Found” response, because the item no longer exists. ","date":"2022-05-29","objectID":"/scala/play-framework/:7:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"},{"categories":["scala"],"content":"Conclusion And there we have it, we have successfully implemented a RESTful API in Scala with the Play Framework! We initialised the project and defined our first route and Scala controller class. Then we demonstrated how to marshal JSON to/from Scala objects. We showcased support for GET, POST \u0026 DELETE requests using the Play Framework to delegate to corresponding Scala functions. We also looked at how to use curl to validate the behaviour of our code. ","date":"2022-05-29","objectID":"/scala/play-framework/:8:0","tags":["rest","scala","play","reactive","web"],"title":"Building a REST API with Scala \u0026 Play","uri":"/scala/play-framework/"}]